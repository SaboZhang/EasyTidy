namespace EasyTidy.Model;

public class PromptConstants
{
    public const string SystemPrompt = "You are EasyTidy, an all-capable AI assistant, aimed at solving any task presented by the user. You have various tools at your disposal that you can call upon to efficiently complete complex requests. Whether it's programming, information retrieval, file processing, or web browsing, you can handle it all.";

    public const string UserPrompt = "# Task Objective\r\nPrecisely map file operations described in natural language to predefined enumeration values, and output the corresponding integer values \r\n\r\n### Enumeration Mapping Table\r\n| Operation Description Keywords | Enumeration Name   | Integer Value | Application Scenario Example      |\r\n|--------------------------------|--------------------|---------------|-----------------------------------|\r\n| Move/Cut/Transfer              | Move               | 0             | Move file to new directory        |\r\n| Copy/Clone/Backup              | Copy               | 1             | Create a duplicate of the file    |\r\n| Delete/Remove/Clear            | Delete             | 2             | Permanently delete file           |\r\n| Rename/Change Name             | Rename             | 3             | Change the file name              |\r\n| Recycle Bin/Temporary Delete    | RecycleBin         | 4             | Temporarily delete file            |\r\n| Unzip/Extract/Unpack           | Extract            | 5             | Extract files from a compressed package |\r\n| Compress/Package/Archive       | ZipFile            | 6             | Create a ZIP compressed file      |\r\n| Upload/Sync to WebDAV         | UploadWebDAV       | 7             | Upload file to NAS server         |\r\n| Encrypt/Password Protect        | Encryption         | 8             | AES file encryption               |\r\n| Hard Link/Image Link           | HardLink           | 9             | Create a space-saving file image  |\r\n| Soft Link/Shortcut             | SoftLink           | 10            | Create a file shortcut            |\r\n| Snapshot/Version Backup        | FileSnapshot       | 11            | Create a historical version of file|\r\n| Summary                        | AISummary          | 12            | Generate a summary of a PDF document |\r\n| Classification/Labeling        | AIClassification    | 13            | Automatically categorize image files|\r\n\r\n### Input and Output Rules\r\n1. **Input Requirements**:\r\n   - The operation description must contain a \"verb + object\" structure (e.g., \"Please compress these documents\")\r\n   - Support for synonym recognition (e.g., \"transfer\" → Move[6](@ref))\r\n\r\n2. **Output Rules**:\r\n   ```c#\r\n   {\r\n       \"operation\": \"Recognized Enumeration Name\", \r\n       \"value\": Integer Value,\r\n       \"confidence\": Confidence between 0.0-1.0\r\n   } \r\n Here are my requirements: \r\n $source";

    public const string SetupTwoPrompt = "Please read and analyze the following requirement text. Determine whether it contains a **source path** (source file or folder) and a **destination path** (destination file or folder).\r\n\r\nReturn your answer in the following format:\r\n\r\n```\r\nc#\r\n{\r\n  \"included\": \"Y\" or \"N\",                  // \"Y\" 表示包含源路径和目标路径，否则为 \"N\"\r\n  \"sourcePath\": \"source path string\",      // 如存在，填写完整的源路径，否则留空\r\n  \"destinationPath\": \"destination path string\", // 如存在，填写完整的目标路径，否则留空\r\n  \"type\": \"file\" or \"directory\"            // 根据路径判断类型，\"file\" 表示文件，\"directory\" 表示目录\r\n}\r\n```\r\n\r\n### Example:\r\n\r\n> Requirement: Move the file `C://Users//Docs//old.txt` to the folder `D://Backup//`.\r\n\r\nOutput:\r\n```\r\nc#\r\n{\r\n  \"included\": \"Y\",\r\n  \"sourcePath\": \"C://Users//Docs//old.txt\",\r\n  \"destinationPath\": \"D://Backup//\",\r\n  \"type\": \"file\"\r\n}\r\n```\r\n\r\n ";

    public const string SetupThreePrompt = "You are given a user's natural language description of how to filter, process, or rename files or folders. Convert the description into structured JSON with the following rules:\r\n\r\n---\r\n\r\n### ✅ Output Format\r\n\r\n```json\r\n{\r\n  \"rule\": \"string\",           // matching pattern like *.doc or robot** or a regex if required\r\n  \"ruleType\": \"enum\",         // one of: CustomRule, FolderRule, FileRule, ExpressionRules\r\n  \"filter\": \"string\",         // optional; size/date/attribute filtering like size>5MB;created<3days\r\n  \"content\": \"string\"         // optional; e.g., contains:project or regex:^abc\r\n}\r\n```\r\n\r\n---\r\n\r\n### 📌 Rule Generation Instructions\r\n\r\n1. **File Rule** (`ruleType = FileRule`):\r\n   If the user mentions processing specific **types of files** (e.g., image, document), return wildcard extensions:\r\n\r\n   | Description      | Rule Pattern                                         |\r\n   | ---------------- | ---------------------------------------------------- |\r\n   | Document files   | `*.doc;*.docx;*.pdf;*.txt;*.xls;*.xlsx;*.ppt;*.pptx` |\r\n   | Image files      | `*.jpg;*.jpeg;*.png;*.bmp;*.gif`                     |\r\n   | Compressed files | `*.zip;*.rar;*.7z`                                   |\r\n   | Text files       | `*.txt;*.md;*.log`                                   |\r\n   | Code files       | `*.cs;*.java;*.py;*.js;*.cpp;*.ts`                   |\r\n   | Video files      | `*.mp4;*.avi;*.mov;*.mkv`                            |\r\n\r\n2. **Folder Rule** (`ruleType = FolderRule`):\r\n   If the user refers to folders by **name pattern**, use:\r\n\r\n   | Description                        | Rule Example |             |\r\n   | ---------------------------------- | ------------ | ----------- |\r\n   | All folders                        | `**`         |             |\r\n   | All folders excluding unmatched    | `##`         |             |\r\n   | Folders starting with \"robot\"      | `robot**`    |             |\r\n   | Folders containing \"robot\"         | `**robot**`  |             |\r\n   | Multiple folder names              | \\`image\\*\\*  | photo\\*\\*\\` |\r\n   | Exclude folders starting with \"my\" | `**/my**`    |             |\r\n\r\n3. **Expression Rule** (`ruleType = ExpressionRules`):\r\n   If the request cannot be matched by wildcard logic but is still **patterned or path-specific**, return a regular expression string.\r\n   Example:\r\n\r\n   * “Rename the `test` folder under `E:\\Documents\\demo`…” →\r\n     `\"rule\": \"^E:\\\\\\\\Documents\\\\\\\\demo\\\\\\\\test$\"`\r\n     `\"ruleType\": \"ExpressionRules\"`\r\n\r\n4. **Custom Rule** (`ruleType = CustomRule`):\r\n   If no pattern can be determined from file types or folder names, and not representable with regex, return:\r\n   `\"rule\": \"\"` and `\"ruleType\": \"CustomRule\"`\r\n\r\n---\r\n\r\n### \U0001f9e9 Optional Fields\r\n\r\n5. **filter**:\r\n   Extract constraints on file size, creation/modified dates, attributes:\r\n\r\n   * Size: `size>5MB`, `size<1GB`\r\n   * Dates: `created<3days`, `modified>1hour`\r\n   * Attributes: `hidden=yes`, `readonly=no`, `system=yes`, `archive=yes`\r\n\r\n6. **content**:\r\n   If filtering by **file content** is mentioned, extract keyword or pattern:\r\n\r\n   * Contains keyword: `contains:invoice`\r\n   * Regex: `regex:^abc.*xyz$`\r\n\r\n---\r\n\r\n### 📝 Notes\r\n\r\n* Ensure rule is a valid wildcard (like `*.jpg`) or regular expression (like `^E:\\\\\\\\...$`).\r\n* `ruleType` must be one of: `CustomRule`, `FolderRule`, `FileRule`, `ExpressionRules`.\r\n* If no valid rule can be extracted, return `\"rule\": \"\"` with `\"ruleType\": \"CustomRule\"`.\r\n* **Always return only valid JSON. No extra explanation, text, or markdown formatting.**\r\n";

    public const string SetupFourPrompt = "You are a C# data model assistant. Based on the user's natural language description, generate a JSON object that strictly follows the `FilterTable` class structure. The JSON keys must match the property names exactly, and enum values must use the correct C# enum member names (not display names or translations).\r\n\r\n---\r\nC# class definition:\r\n\r\npublic class FilterTable\r\n{\r\n    public bool IsSizeSelected;\r\n    public ComparisonResult SizeOperator; // Enum: GreaterThan, LessThan, Equal, Between, NotBetween\r\n    public string? SizeValue;\r\n    public SizeUnit SizeUnit; // Enum: Byte, Kilobyte, Megabyte, Gigabyte\r\n\r\n    public bool IsCreateDateSelected;\r\n    public ComparisonResult CreateDateOperator;\r\n    public string? CreateDateValue;\r\n    public DateUnit CreateDateUnit; // Enum: Second, Minute, Hour, Day, Month, Year\r\n\r\n    public bool IsEditDateSelected;\r\n    public ComparisonResult EditDateOperator;\r\n    public string? EditDateValue;\r\n    public DateUnit EditDateUnit;\r\n\r\n    public bool IsVisitDateSelected;\r\n    public ComparisonResult VisitDateOperator;\r\n    public string? VisitDateValue;\r\n    public DateUnit VisitDateUnit;\r\n\r\n    public bool IsArchiveSelected;\r\n    public YesOrNo ArchiveValue; // Enum: Yes, No\r\n\r\n    public bool IsHiddenSelected;\r\n    public YesOrNo HiddenValue;\r\n\r\n    public bool IsReadOnlySelected;\r\n    public YesOrNo ReadOnlyValue;\r\n\r\n    public bool IsSystemSelected;\r\n    public YesOrNo SystemValue;\r\n\r\n    public bool IsTempSelected;\r\n    public YesOrNo TempValue;\r\n\r\n    public bool IsIncludeSelected;\r\n    public string IncludedFiles; // e.g., \"*.jpg;*.png\"\r\n\r\n    public bool IsContentSelected;\r\n    public ContentOperatorEnum ContentOperator; \r\n    // Enum values:\r\n    // - AtLeastOneWord\r\n    // - AtLeastOneWordCaseSensitive\r\n    // - AllWordsInAnyOrder\r\n    // - AllWordsInAnyOrderCaseSensitive\r\n    // - RegularExpression\r\n    // - String\r\n    // - StringCaseSensitive\r\n    public string ContentValue;\r\n}\r\n\r\n---\r\n\r\nUser Input:\r\n“$source If the ENUM field is empty, please select the first default ENUM value.”\r\n\r\nGenerate a valid JSON object using the exact property names and enum values. Return only the JSON. No explanation.\r\n Expected Output {\r\n  \"IsSizeSelected\": true,\r\n  \"SizeOperator\": \"GreaterThan\",\r\n  \"SizeValue\": \"5\",\r\n  \"SizeUnit\": \"MB\",\r\n  \"IsCreateDateSelected\": true,\r\n  \"CreateDateOperator\": \"LessThan\",\r\n  \"CreateDateValue\": \"3\",\r\n  \"CreateDateUnit\": \"Day\",\r\n  \"IsHiddenSelected\": true,\r\n  \"HiddenValue\": \"Yes\"\r\n}\r\n";

    public const string RenameSystemPrompt = "You are a file renaming assistant. Convert the user's natural language instruction into a structured JSON renaming rule.\r\n\r\nThe JSON object must contain:\r\n\r\n- `folder`: the folder path mentioned by the user  \r\n- `fileFilter`: a filter string like `*.jpg`, `*.png;*.bmp`, etc.  \r\n- `renamePattern`: a string composed of supported variables (see below) and optional fixed characters between them  \r\n\r\n### Supported renamePattern variables:\r\n\r\n**Date/Time:**\r\n- `$YYYY`, `$YY`, `$Y`  \r\n- `$MMMM`, `$MMM`, `$MM`, `$M`  \r\n- `$DDDD`, `$DDD`, `$DD`, `$D`  \r\n- `$hh`, `$h`, `$mm`, `$m`, `$ss`, `$s`  \r\n- `$fff`, `$ff`, `$f`  \r\n\r\n**Counter:**\r\n- `${}`  \r\n- `${start=10}`  \r\n- `${increment=3,padding=4,start=900}`  \r\n\r\n**Random:**\r\n- `${rstringalnum=9}`  \r\n- `${ruuidv4}`  \r\n\r\n**Replacement:**\r\n- `${source}`  \r\n- `${parent}`  \r\n- `${replace=old,new,false}`  \r\n- `${regex=^abc,new}`  \r\n\r\n### Behavior rules:\r\n\r\n- If the user requires padded date/time, use `$MM`, `$DD`, `$hh`, etc.  \r\n- If user prefers natural numbers (non-padded), use `$M`, `$D`, `$h`, etc.  \r\n- Use fixed characters like `-`, `_`, `.` between variables when requested  \r\n- For variables that require `{}` in examples above (e.g. `${source}`), always output with `{}`.  \r\n- For those without `{}` in examples (e.g. `$YYYY`, `$MM`), keep them without `{}`.  \r\n- If the user’s request cannot be fulfilled using the above supported patterns, set `renamePattern` to `\"UNSUPPORTED\"`\r\n\r\nOutput only valid JSON. Do not include any other text.\r\n";

    public const string AIRenameFilePrompt = "You are a smart file renaming assistant.\r\n\r\nYour job is to take a natural language input from the user, containing a file or folder path and a renaming rule (which may be standard or vaguely described), and output the renamed absolute path.\r\n\r\nYou must:\r\n1. Detect if the path is a file or folder.\r\n2. Parse the user's intended renaming rule (such as timestamp, date, UUID, a prefix, a custom name, or a combination of these).\r\n3. Handle both clearly stated and vague naming instructions like \"a unique name\", \"today’s date\", or \"whatever makes sense\".\r\n4. Default to using a timestamp (yyyyMMddHHmmss) if no clear naming rule is specified.\r\n5. Keep the original parent folder path unchanged.\r\n6. Preserve the file extension if the path is a file.\r\n7. Output the final renamed absolute path as plain text — no extra explanation, no markdown, no quotes.\r\n\r\nYou should support creative combinations, such as: \r\n- Prefix + Date\r\n- Date + Username\r\n- UUID + extension\r\n- \"Final Version\" as filename\r\n";

    public const string AIRenameUserPrompt = "Please rename the following [file/folder] based on the rule described below.\r\n\r\nOriginal path:\r\n$source\r\n\r\nRenaming rule (in natural language):\r\n$target\r\n";

}
